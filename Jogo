let pipaPos, inimigaPos, aliadaPos, pipaEspecialPos;
let score = 0;
let gameOver = false;
let telaAtual = 0; // 0 - Menu, 1 - Jogo, 2 - Game Over
let skyTop, skyBottom;
let inimigaCortante = false;

// Cores para as pipas
let coresPipaPrincipal = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00'];
let coresPipaInimiga = ['#FF6464', '#FF9696', '#FFCCCC', '#FF3232'];
let coresPipaAliada = ['#64FF64', '#96FF96', '#C8FF96', '#32FF32'];
let coresMenu = ['#FF0000', '#00FF00', '#0000FF'];

// Variáveis para a colisão
let colisaoInimiga = false;
let colisaoAliada = false;
let colisaoEspecial = false;
let tempoColisaoInimiga = 0;
let tempoColisaoAliada = 0;

// Variáveis para o pop-up de pontuação
let popupTexto = "";
let popupTempo = 0;

let curvaAmplitude = 50; // Amplitude da curvatura
let ultimaPosX = 0; // Última posição X da pipa
let tamanhoPipaPrincipal = 100; // Tamanho inicial da pipa principal

let ps; // Sistema de partículas

function setup() {
  createCanvas(windowWidth, windowHeight);
  
  // Cores do céu
  skyTop = color(0, 100, 200);
  skyBottom = color(135, 206, 250);
  
  // Definir posição inicial
  pipaPos = createVector(width / 2, height - 100);
  inimigaPos = createVector(random(width), -100);
  aliadaPos = createVector(random(width), -100);
  pipaEspecialPos = createVector(random(width), -100); // Posição da pipa especial
  ultimaPosX = pipaPos.x; // Inicializa a última posição X
  ps = new ParticleSystem(createVector(0, 0)); // Inicializa o sistema de partículas
}

function draw() {
  if (telaAtual === 0) {
    desenhaMenu();
  } else if (telaAtual === 1) {
    desenhaCenario();
    movePipa(); // Mover a pipa de acordo com a posição do mouse
    desenhaPipa();
    movimentarInimiga();
    movimentarAliada();
    movimentarPipaEspecial(); // Adiciona movimentação da pipa especial
    desenhaPlacar();
    verificaColisoes();
    ps.run(); // Executa o sistema de partículas
    desenhaPopup(); // Exibe o pop-up de pontuação
  } else if (telaAtual === 2) {
    // Exibir tela de Game Over
  }
}

function desenhaMenu() {
  background(239, 3, 252);
  textAlign(CENTER);
  textSize(32);
  text("PUXE a linha para iniciar", width / 2, height / 2);
}

function desenhaCenario() {
  // Desenhar o degradê de fundo
  for (let i = 0; i < height; i++) {
    let inter = map(i, 0, height, 0, 1);
    let c = lerpColor(skyTop, skyBottom, inter);
    stroke(c);
    line(0, i, width, i);
  }
}

function desenhaPipa() {
  fill(255); // Cor de fundo para a linha
  let tamanho = tamanhoPipaPrincipal;

  // Desenhar a pipa principal com cores diferentes para cada triângulo
  desenhaPipaTriangular(pipaPos.x, pipaPos.y, coresPipaPrincipal, tamanho);
  
  // Desenhar a linha com curvatura
  stroke(255);
  noFill();
  
  let linhaBaseX = width / 2; // Ponto central da linha na parte inferior
  let linhaY = height; // Ponto inferior da linha
  
  // Calcular a curvatura
  let curvaOffset = 2;
  if (pipaPos.x < ultimaPosX) {
    curvaOffset = -curvaAmplitude; // Curva para a esquerda
  } else if (pipaPos.x > ultimaPosX) {
    curvaOffset = curvaAmplitude; // Curva para a direita
  }
  
  // Atualiza a última posição X
  ultimaPosX = pipaPos.x;

  // Começar a definir a curva
  beginShape();
  curveVertex(pipaPos.x + 38, pipaPos.y + tamanho / 12); // Ponto superior
  curveVertex(pipaPos.x + 38, pipaPos.y + tamanho / 12); // Ponto superior (repetido)
  curveVertex(linhaBaseX, pipaPos.y + 600 + curvaOffset); // Ponto de controle da curvatura
  curveVertex(linhaBaseX, linhaY); // Ponto inferior fixo
  curveVertex(linhaBaseX, linhaY); // Ponto inferior (repetido)
  endShape();
}

function desenhaPipaTriangular(x, y, cores, tamanho) {
  let base = tamanho; // Base da pipa
  let altura = tamanho; // Altura da pipa
  
  // Desenhar os quatro triângulos retângulos
  for (let i = 0; i < 4; i++) {
    fill(cores[i]);
    noStroke();
    
    switch (i) {
      case 0: // Triângulo 1 (superior esquerdo)
        triangle(x, y, x + base / 2, y - altura, x + base / 2, y);
        break;
      case 1: // Triângulo 2 (superior direito)
        triangle(x + base, y, x + base / 2, y - altura, x + base / 2, y);
        break;
      case 2: // Triângulo 3 (inferior esquerdo)
        triangle(x, y, x + base / 2, y + altura, x + base / 2, y);
        break;
      case 3: // Triângulo 4 (inferior direito)
        triangle(x + base, y, x + base / 2, y + altura, x + base / 2, y);
        break;
    }
  }
}

function movimentarInimiga() {
  inimigaPos.y += 6; // Movimento descendente da pipa inimiga
  if (inimigaPos.y > height) {
    inimigaPos.set(random(width), -100);
  }
  
  fill(255); // Cor de fundo para a linha
  desenhaPipaTriangular(inimigaPos.x, inimigaPos.y, coresPipaInimiga, 60); // Desenhar pipa inimiga
}

function movimentarAliada() {
  aliadaPos.y += 3; // Movimento descendente da pipa aliada
  if (aliadaPos.y > height) {
    aliadaPos.set(random(width), -100);
  }
  
  fill(255); // Cor de fundo para a linha
  desenhaPipaTriangular(aliadaPos.x, aliadaPos.y, coresPipaAliada, 60); // Desenhar pipa aliada
}

function movimentarPipaEspecial() {
  pipaEspecialPos.y += 4; // Movimento descendente da pipa especial
  if (pipaEspecialPos.y > height) {
    pipaEspecialPos.set(random(width), -100); // Reposiciona a pipa especial
  }
  
  fill(255, 200, 0); // Cor para a pipa especial
  desenhaPipaTriangular(pipaEspecialPos.x, pipaEspecialPos.y, coresPipaAliada, 60); // Desenhar pipa especial
}

function desenhaPlacar() {
  textAlign(LEFT);
  textSize(24);
  fill(0);
  text("Pontuação: " + score, 10, 30);
}

function verificaColisoes() {
  // Verificar se a linha da pipa principal passou pela pipa inimiga
  if (pipaPos.x + 50 > inimigaPos.x && pipaPos.x + 50 < inimigaPos.x + 60) {
    if (pipaPos.y < inimigaPos.y + 60) {
      inimigaPos.set(-100, -100); // Remove a pipa inimiga
      score += 200; // Ganho de pontos
      mostraPopup("Pontuação: +200");
      ps.origin.set(pipaPos.x + 30, pipaPos.y + 30); // Define a origem das partículas
      for (let i = 0; i < 100; i++) { // Gera partículas
        ps.addParticle();
      }
    }
  }
  
  // Verificar colisão com pipa aliada
  if (pipaPos.x + 50 > aliadaPos.x && pipaPos.x + 50 < aliadaPos.x + 60) {
    if (pipaPos.y < aliadaPos.y + 60) {
      aliadaPos.set(-100, -100); // Remove a pipa aliada
      score += 200; // Ganho de pontos
      mostraPopup("Pontuação: +200");
      ps.origin.set(pipaPos.x + 30, pipaPos.y + 30); // Define a origem das partículas
      for (let i = 0; i < 100; i++) { // Gera partículas
        ps.addParticle();
      }
      aliadaPos.set(random(width), -100); // Reposiciona a pipa aliada
    }
  }
  
  // Verificar colisão com pipa especial
  if (pipaPos.x + 50 > pipaEspecialPos.x && pipaPos.x + 50 < pipaEspecialPos.x + 60) {
    if (pipaPos.y < pipaEspecialPos.y + 60) {
      pipaEspecialPos.set(-100, -100); // Remove a pipa especial
      score += 300; // Ganho de pontos
      mostraPopup("Pontuação: +300");
      ps.origin.set(pipaPos.x + 30, pipaPos.y + 30); // Define a origem das partículas
      for (let i = 0; i < 100; i++) { // Gera partículas
        ps.addParticle();
      }
    }
  }
}

function mostraPopup(texto) {
  popupTexto = texto;
  popupTempo = 40; // Exibir por 40 frames
}

function desenhaPopup() {
  if (popupTempo > 0) {
    textAlign(CENTER);
    textSize(20);
    text(popupTexto, width / 2, height / 2);
    popupTempo--;
  }
}

function keyPressed() {
  if (telaAtual === 0) {
    if (keyCode === ENTER) {
      telaAtual = 1;
      score = 0;
      pipaPos.set(width / 2, height - 100);
      inimigaPos.set(random(width), -100);
      aliadaPos.set(random(width), -100);
      pipaEspecialPos.set(random(width), -100); // Reposiciona a pipa especial
      ultimaPosX = pipaPos.x; // Resetar a última posição
    }
  } else if (telaAtual === 2 && key === 'r') {
    telaAtual = 0; // Volta ao menu
  }
}

function movePipa() {
  // Movimentação com resposta mais lenta em relação ao mouse
  let velocidade = 0.8; // Diminuição da velocidade de resposta ao movimento do mouse
  pipaPos.x += constrain(mouseX - (pipaPos.x + 50), -velocidade * 10, velocidade * 10);
  pipaPos.y += constrain(mouseY - (pipaPos.y + 50), -velocidade * 10, velocidade * 10);
  
  // Ajustar o tamanho da pipa principal com base na posição Y
  let fatorAltura = map(pipaPos.y, height, 0, 1, 0.5); // O tamanho diminui quando sobe
  tamanhoPipaPrincipal = 100 * fatorAltura; // Tamanho entre 50 e 100
}

// Classe para partículas
class Particle {
  constructor(l) {
    this.position = l.copy();
    this.velocity = createVector(random(-1, 1), random(-2, 0));
    this.acceleration = createVector(0, 0.05);
    this.lifespan = 255.0;
  }

  run() {
    this.update();
    this.display();
  }

  update() {
    this.velocity.add(this.acceleration);
    this.position.add(this.velocity);
    this.lifespan -= 1.0;
  }

  display() {
    stroke(255, this.lifespan);
    fill(255, this.lifespan);
    ellipse(this.position.x, this.position.y, 8, 8);
  }

  isDead() {
    return this.lifespan < 0.0;
  }
}

// Classe para o sistema de partículas
class ParticleSystem {
  constructor(position) {
    this.origin = position.copy();
    this.particles = [];
  }

  addParticle() {
    this.particles.push(new Particle(this.origin));
  }

  run() {
    for (let i = this.particles.length - 1; i >= 0; i--) {
      let p = this.particles[i];
      p.run();
      if (p.isDead()) {
        this.particles.splice(i, 1);
      }
    }
  }
}
